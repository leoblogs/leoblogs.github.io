import{_ as n,o as s,c as a,b as t}from"./app-6ldeWLzQ.js";const p={},e=t(`<h1 id="基于-redis-的分布式锁实现" tabindex="-1"><a class="header-anchor" href="#基于-redis-的分布式锁实现" aria-hidden="true">#</a> 基于 Redis 的分布式锁实现</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>在并发场景下，为了保证数据的一致性，需要通过加锁来实现。单机场景下，多线程修改本地数据，直接通过加锁互斥访问即可实现。但在分布式场景下，如果是多个实例修改一个数据，例如电商中秒杀，可能同时会有多个实例要访问数据库修改商品数量，这时就需要用到分布式锁，让多个实例互斥访问数据库。</p><h3 id="本地锁" tabindex="-1"><a class="header-anchor" href="#本地锁" aria-hidden="true">#</a> 本地锁</h3><p>使用go自带的互斥锁实现多线程数据修改。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">type</span> Count <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	num <span class="token builtin">int</span>
	mtx sync<span class="token punctuation">.</span>Mutex
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Count<span class="token punctuation">)</span> <span class="token function">Change</span><span class="token punctuation">(</span>v <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	c<span class="token punctuation">.</span>mtx<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>num <span class="token operator">+=</span> v
	c<span class="token punctuation">.</span>mtx<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cnt <span class="token operator">:=</span> Count<span class="token punctuation">{</span>num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	N <span class="token operator">:=</span> <span class="token number">1000</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			cnt<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			ch <span class="token operator">&lt;-</span> <span class="token number">1</span> <span class="token comment">//线程完成任务后通知主线程</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token operator">&lt;-</span>ch <span class="token comment">//每次从chan中拿出一个，拿完N个时，新建的所有线程都执行完毕。</span>
		<span class="token comment">//注意此时新建线程不一定都结束了，而是线程的内容执行完了</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span>
	<span class="token comment">/* !+output
	不加锁的情况下：995左右波动（可以自己运行尝试）
	加锁情况下： 1000
	!-output
	*/</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h3><p>分布式锁就是在分布式环境下抢占一把锁，是实现分布式系统同步访问共享资源的一种方式。</p><p>分布式锁相比本地锁的难点在于需要考虑网络。</p><p>基于 Redis 分布式锁需要考虑的问题：</p><ul><li>加锁失败/或超时怎么处理？</li><li>用户应该只能释放自己加的锁，如何实现</li><li>分布式锁的过期时间怎么设置</li></ul><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h2><h3 id="加锁" tabindex="-1"><a class="header-anchor" href="#加锁" aria-hidden="true">#</a> 加锁</h3><p>基于 Redis 中的 setnx(set if not exists) 来实现加锁，setnx 命令在指定的 key 不存在时，为 key 设置指定的值，设置成功，返回 1 。 设置失败，返回 0 。</p><p>使用key作为锁名，同时为了保证只能释放自己加的锁，将val设置为token，只用加锁的用户知道，在释放锁时，如果用户提供的token与Redis中设置的token不同则无法释放锁。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> client <span class="token operator">*</span>redis<span class="token punctuation">.</span>Client

<span class="token comment">// Lock 实现分布式加锁</span>
<span class="token comment">// key代表加锁的名称，token是该锁的一个令牌、标识，用来区分是谁加的锁 可以使用 uuid / 生成随机字符串等标识</span>
<span class="token keyword">func</span> <span class="token function">Lock</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">,</span> expiration time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ok<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">SetNX</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token<span class="token punctuation">,</span> expiration<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		ok<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">SetNX</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token<span class="token punctuation">,</span> expiration<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//如果失败再尝试一次</span>
		<span class="token keyword">return</span> ok<span class="token punctuation">,</span> err                                           <span class="token comment">//无论尝试是否成功，直接返回结果</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ok<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="释放" tabindex="-1"><a class="header-anchor" href="#释放" aria-hidden="true">#</a> 释放</h3><p>获取要释放锁的token，与用户提供的token对比，如果相同释放锁，不同则不释放锁，返回error</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Unlock 实现分布式解锁</span>
<span class="token comment">// 解锁需要指定锁名和token，通过token可以辨别当前锁是谁持有，不能释放其他人的锁</span>
<span class="token keyword">func</span> <span class="token function">Unlock</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	val<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//查询锁key对应的token</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> val <span class="token operator">!=</span> token <span class="token punctuation">{</span> <span class="token comment">//判断是否是该用户加的锁</span>
		<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">&quot;解锁失败，不能释放其他人的锁&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	client<span class="token punctuation">.</span><span class="token function">Del</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 将锁释放</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有一个问题，当判断完锁是当前用户持有时（第8行），还没来得及执行释放锁，恰好锁超时过期啦，且其他用户获取了该锁，这时释放锁就会导致释放了他人的锁。</p><p>要避免这种情况，可以将查询、判断、释放修改为原子操作。考虑到Redis是单线程服务，使用Redis脚本实现以上三个操作，达到原子效果。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">Unlock1</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	UnlockScript <span class="token operator">:=</span> redis<span class="token punctuation">.</span><span class="token function">NewScript</span><span class="token punctuation">(</span><span class="token string">\`
		if redis.call(&quot;GET&quot;, KEYS[1]) = KEYS[2] then
			return redis.call(&quot;del&quot;, KEYS[1]) else 
			return 0 
		end\`</span><span class="token punctuation">)</span> <span class="token comment">//新建一个Redis脚本，由于Redis是单线程，所以脚本中的内容一定可以原子执行。</span>

	n<span class="token punctuation">,</span> err <span class="token operator">:=</span> UnlockScript<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>key<span class="token punctuation">,</span> token<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">&quot;解锁失败&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="续约" tabindex="-1"><a class="header-anchor" href="#续约" aria-hidden="true">#</a> 续约</h3><p>通常无法确定一个锁的超时时间，同时也不能设置锁的超时时间为无限长，即没有超时时间，这样当程序异常崩溃时，锁将无法被获取。因此通过续约机制来实现锁的超时时间动态延长。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// 续约机制</span>
<span class="token keyword">func</span> <span class="token function">AutoRefresh</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> token <span class="token builtin">string</span><span class="token punctuation">,</span> expiration time<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span> interval time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		ticker <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>interval<span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">{</span> <span class="token comment">//一直循环</span>
			<span class="token keyword">select</span> <span class="token punctuation">{</span>
			<span class="token keyword">case</span> <span class="token operator">&lt;-</span>ticker<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
				val<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">||</span> val <span class="token operator">!=</span> token <span class="token punctuation">{</span> <span class="token comment">//判断是否是该用户加的锁</span>
					<span class="token keyword">return</span> <span class="token comment">//如果不是证明用户的锁已经释放</span>
				<span class="token punctuation">}</span>
				<span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">Expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> expiration<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//修改过期时间</span>
				<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
					<span class="token keyword">return</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是基于Redis实现的一个简单分布式锁。</p>`,26),o=[e];function c(i,l){return s(),a("div",null,o)}const k=n(p,[["render",c],["__file","redis_lock.html.vue"]]);export{k as default};
